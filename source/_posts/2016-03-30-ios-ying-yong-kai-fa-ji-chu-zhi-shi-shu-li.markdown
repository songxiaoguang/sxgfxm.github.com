---
layout: post
title: "iOS - 应用开发基础知识梳理"
date: 2016-03-30 08:38:24 +0800
comments: true
categories: iOS
tags: 
keywords: iOS
---


这篇文章主要自己对iOS应用开发基础知识的梳理，用于基础知识的复习巩固，也可作为笔试、面试的资料。本人作为iOS开发初学者，能力有限，如果不足之处请多多包涵和在评论指出，一定及时更新回复。

##目录

- Objective-C语言相关
- Objective-C语法相关

##Objective-C语言相关

- 面向对象编程特点
	- 封装：把数据及操作这些数据的方法封装为类，只对外暴露接口使用；
	- 继承：子类可以继承父类的变量和方法，提高代码重用性，单继承特性；
	- 多态：子类对象可以赋值给父类对象；不同对象对相同的消息做出不同的响应。

---

- 动态语言特性
	- 动态类型定义：在代码中对象定义为id类型，直到运行时才确定类型；
	- 动态内存分配：在运行时，类创建新对象；
	- 动态消息绑定：在运行时，匹配消息中的selector与receiver中的方法实现。

---

- 动态类型定义
	- 使用id类型定义的对象，在运行时才知道该对象属于哪个类；
	- 运行时系统会查询该对象的isa指针，从而知道它属于哪个类；
	- 动态类型定义是动态绑定的基础。

---

- 动态消息绑定
	- 对message做出反应的method直到程序运行时才能确定；
	- function和parameters在编译时就被绑定到一起；
	- receiver和message直到程序运行且message被发出时才被绑定到一起；
	- 动态消息绑定使每个对象都可以有某一方法的个性化版本；
	- 通过改变receiver，且receiver运行时才能确定，从而同一message产生不同的结果；
	- receiver的确定受用户操作影响；
	- 消息发送者不必在意谁接收该消息，不同的接收方会采取个性化操作；
	- 消息本身也可以动态确定。

---

- 消息传递机制
	- 给某个对象发送一个消息，该对象根据消息采取特定的操作。
	- 发出消息——>运行时消息处理例程获取receiver和消息中的selector  
	——>查找接收器中的同名方法——>把接收器的实例变量传递给这个方法——>调用该方法。

---

- 静态语言特性
	- 静态类型定义：使用类名直接定义对象，增加给编译器和读者的信息量；
	- 动态内存分配：并不影响该对象在运行时如何创建；
	- 动态消息绑定：并不影响该对象接受消息的方式。

---

- 静态类型定义
	- 直接使用类名定义的对象，在编译时即知道该对象属于哪个类；
	- 静态类型定义的对象，编译器可以对其进行类型检查；
	- 可静态定义某对象为其父类对象。

---

- 动态行为与静态行为比较
	- 动态行为的优点：使面向对象编程更加灵活，强大。
	- 动态行为的缺点：无法进行类型检查，运行时容易出错；消息传递比函数调用慢。
	- 静态行为的优点
		- 允许编译时进行类型检查：
			- 当向一个静态定义的receiver发送消息时，编译器可检查其是否可以响应；
			- 当静态定义的对象赋值给一个静态定义的变量时，编译器可检查类型是否一致。
		- 打破同名方法需要相同的返回值和参数类型的限制：
			通常，不同类的同名方法需要有相同的返回值和参数类型，来使编译器允许动态绑定，因为编译器不知道接收器属于哪个类，所以只创建一个方法描述。当接收器为静态定义的对象时，编译器在编译时就知道其所属类的信息，可以为其单独创建方法描述，从而打破同名限制。
		- 允许使用->来访问实例变量。

---

- 协议Protocol
	- 协议声明了一组方法，这组方法可以被所有类实现；
	- 遵守某协议需要实现该协议中@required修饰的方法；
	- 使用协议的三种情况：
		- 声明想让其他类实现的方法（代理设计模式时采用）；
		- 声明interface并隐藏它的类；
		- 实现类之间共享某些方法。
	- 协议是独立存在的，协议的创建不需要与任何类建立联系；
	- 协议声明了一组方法，并不与类建立连接，把方法从类的结构中解放出来；
	- 协议不关心具体哪个类实现了自己，只关心这个类是否完整实现了自己声明的所有需要实现的方法；
	- 协议使实现该协议的类具有相似的方法集，不需要有继承关系；
	- 对象可以按类划分，也可以按协议划分；
	- 继承：向类中添加父类中的方法；
	- 协议：向类中添加协议中的方法；
	- 正式协议：
	- 非正式协议：

---

- 类别Category
	- 类别可以实现在不修改源代码的情况下，为类添加方法；
	- 类别一般只可以添加方法，可以通过Runtime实现添加属性；
	- 类别扩充了类的功能，而不必通过子类来实现，且添加的方法与类中的方法地位相同；
	- 类别可以把类的实现放在不同的文件中；
	- 如果扩展的方法与原始类中的方法相同，则会隐藏原始方法；
	- 不可在扩展方法中通过super调用原始方法；

---

- 扩展Extention
	- 扩展可以在源代码的基础上，添加方法和属性；
	- 扩展允许一个类拥有一个私有的interface，且可由编译器验证。

---

- 内存管理机制
	- Reference Count，引用计数。通过对象的引用计数来判断是否释放该对象，当对象的引用计数为0时，系统会调用dealloc方法来释放该对象；
	- retain，retainCount++；release，retainCount--；
	- 黄金法则：通过alloc、new、copy获取的对象，需要对其使用release或autorelease释放。
	- MRC，手动内存管理，
	- ARC，自动内存管理，iOS 5.0后采用，编译时自动插入retain、release和autorelease，  
	减轻开发者负担，但只针对Foundation框架下的对象；
	- GC：垃圾回收机制，运行时周期性的检查是否有不再使用的对象并进行释放，  
	iOS不支持垃圾回收机制。
	- 非ARC工程中采用ARC去编译某些类：-fobjc-arc；
	- 在ARC工程中采用MRC去编译某些类：-fno-fobjc-arc;

---

- 属性Property
	- 提供了一种清晰、准确的描述，accessor方法是如何工作的；
	- 编译器可以自动生成访问实例变量的方法，减少代码量；
	- @synthesize告诉编译器实现响应的accessor方法，@dynamic动态实现；
	- 属性修饰词：
		- 设置accessor方法的名字
			- getter = getterName
			- setter = setterName
			- 默认getter = propertyName，setter = setPropertyName：
		- 设置property的可写性
			- readwrite：可读可写，默认；
			- readonly：只可读，不会生成setter方法；
		- 设置proper的原子性
			- atomic：原子的，保证访问时线程安全，开销大；
			- nonatomic：非原子的，当确定该属性不会多线程访问时采用，节省开销；
		- 设置setter方法的语义
			- assign：常用于修饰基本数据类型，默认；
			- copy：当该对象被拷贝时，向该对象发送release消息；
			- retain：赋值时先release旧值，再retain新值，常用语对象；
			- strong：与目标对象有strong relationship
			- weak：与目标对象有weak relationship。当目标对象被释放时，该属性值自动置nil；
		
---

- 强引用与弱引用
	- 







